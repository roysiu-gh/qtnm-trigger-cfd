# qtnm-trigger-cfd

## Overview
### General
The data output from the Quantum Technology for Neutrino Mass (QTNM) experiment contains a chirped signal. A (level 0) trigger is needed for the data acquisition (DAQ) system to collect these chirped signals. We have decided to use an FPGA for implementation due to performance considerations. The trigger should fire on that chirp. The first half either uses a [[Lock-in amplifier]] (LIA) (see [WarwickEPR](https://github.com/WarwickEPR/RePLIA/tree/master/fpga)) or a [[Matched filter]]. This repository contains the second half of the trigger, which assumes the use of a Matched Filter. The LIA may be used for further offline analysis.
### Second half
The Matched Filter output looks like noise with some human-identifiable peaks. The basic process consists of an amplifier, a low-pass filter, the discriminator, then a zero-crossing detector. I have programmed alternative discriminators but we will use a Constant Fraction Discriminator (CFD). The analysis (Python) code also allows for running another filter and running another discriminator before the zero detector.

> amplifier -> filter -> discriminator (-> filter (-> discriminator -> filter)) -> zero detector
## Analysis & Usage
To quickly see the outputs of this project, run the JupyterLab notebooks.

**Algorithms**
Most functions that could be written in Verilog are written here as generators to closer replicate Verilog description. Numba compilation is used to speed up some functions. `XXX_wrapper` functions return the corresponding function with all parameters preset, so that only the input series `x_all` is required. `XXX_extracted` functions exist because Numba doesn't support the \*\*kwargs construct. They ignore arguments irrelevant (hard-coded) to the wrapped functions, and return the output of the wrapped function. See `REAME_analysis.md` for details.
- filter
    - `lp_filter_iir`: A low-pass single-pole IIR filter. This follows the usual algorithm, to avoid use of floating points, the normal parameter `decay` is split into an integer numerator and denominator. Instead of multiplying by `decay`, the signal is multiplied by the numerator then divided by the denominator. The denominator must be a power of 2 so that we can use an arithmetic shift for fast division without use of floating points.
    - `sma_convolve`: A Simple Moving Average implemented with convolution.
    - `wma_linear_convolve`: A Weighted Moving Average implemented with convolution.
    - `ema_convolve`: An Exponentially Weighted Moving Average implemented with convolution.
- discriminator
    - `cfd`, `cfd2`, `cfd3`: Simulation of the constant fraction discriminator (CFD) described in Verilog and some variations.
    - `diff`: A discriminator using the difference between neighbouring values. Essentially useless.
    - `mad_discriminator`: A discriminator which triggers when the signal exceeds a preset Mean Average Deviation from the (simple moving) mean.
- zero detector
    - `zero_detector`: Finds positions where the signal is either rising or falling through zero using XOR on the most significant bit.
    - `zero_detector2`: A variation of `zero_detector` that only detects rising zero crossings.
## Data
**Input data**
The Matched Filter output.

The following prefixes classify the type of input data:
- SX - pure signal, no noise
- XN - no signal, pure noise
- SN - both signal and noise

The files SX1, SX2, SX3; XN1, XN2; SN1, SN2 are the original data, with no accompanying truth data. The files XN3, XN4; SN3, SN4 contain newer data (using the 33-cycle Matched Filter), also contain truth data. The files were decoded using the [Liquid Instruments File Converter](https://www.liquidinstruments.com/products/apis/li-file-converter/) into a NumPy file with two/three series: time, signal(, truth data).

As the initial development didn't have access to input data with truth data, I artificially created some data to use. The SX1 truth data was generated by splitting the dataset into (known) 2ms chunks, finding the mean position of the peaks, and repeating a 2ms-long array of zeros with a single one at the mean peak position. SX1+XN2 is a simple point-wise sum of SX1 and XN2, and the generated SX1 truth data can be used to generate ROC curves with this.

**Output data**
Saved to CSVs using pandas. Look at header rows for formats. I have used shorthand to name the files for `vary_filter_roc_data`. Usually with a suffix in the format: `input data, filter, number of times filter run, tolerance`.

For example, `vary_filter_roc_data - SX1+XN2, SMA-C, LPx1, Tol 1s, SecTime 250e-6s.csv` denotes the output data from analysing: the artificial SX1+XN2 with (also artificial) generated truth data, using `sma_convolve`, running the filter once, with tolerance of 1 second, and `section_time` set to 0.25 milliseconds.
## Plots
See the documentation for `analysis.plot_data.py` in `REAME_analysis.md`.

## License & Copyright
Distributed under the MIT License. See `LICENSE.txt` for more information. Copyright (c) 2023 Roy Siu.

## Contact
Roy Siu - [GitHub: roysoup](https://github.com/roysoup)

Project Link: [https://github.com/roysoup/qtnm-trigger-cfd](https://github.com/roysoup/qtnm-trigger-cfd)
